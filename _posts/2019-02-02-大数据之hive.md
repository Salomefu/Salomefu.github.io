---
layout: post
title: 大数据之hive
subtitle: 
date: 2019-02-02
author: Salome
header-img: img/post-bg-2015.jpg
catalog: true
tags:

   - big data


---

# 基本概念

Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能。

本质是：将HQL转化成MapReduce程序

![](https://tva1.sinaimg.cn/large/006tNbRwly1ga7nvbw03wj30wk0dwjvp.jpg)

1）Hive处理的数据存储在HDFS

2）Hive分析数据底层的实现是MapReduce

3）执行程序运行在Yarn上

##### 优点

1)   操作接口采用类SQL语法，提供快速开发的能力（简单、容易上手）。

2)   避免了去写MapReduce，减少开发人员的学习成本。

3)   Hive的执行延迟比较高，因此Hive常用于数据分析，对实时性要求不高的场合。

4)   Hive优势在于处理大数据，对于处理小数据没有优势，因为Hive的执行延迟比较高。

5)   Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。

##### 缺点

1）Hive的HQL表达能力有限

（1）迭代式算法无法表达

（2）数据挖掘方面不擅长，由于MapReduce数据处理流程的限制，效率更高的算法却无法实现。

2）Hive的效率比较低

（1）Hive自动生成的MapReduce作业，通常情况下不够智能化

（2）Hive调优比较困难，粒度较粗

  ##### 架构

![](https://tva1.sinaimg.cn/large/006tNbRwly1ga7o06esifj30ok0m6tbm.jpg)

1．用户接口：Client

CLI（command-line interface）、JDBC/ODBC(jdbc访问hive)、WEBUI（浏览器访问hive）

2．元数据：Metastore

元数据包括：表名、表所属的数据库（默认是default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等；

默认存储在自带的derby数据库中，推荐使用MySQL存储Metastore

3．Hadoop

使用HDFS进行存储，使用MapReduce进行计算。

4．驱动器：Driver

（1）解析器（SQL Parser）：将SQL字符串转换成抽象语法树AST，这一步一般都用第三方工具库完成，比如antlr；对AST进行语法分析，比如表是否存在、字段是否存在、SQL语义是否有误。

（2）编译器（Physical Plan）：将AST编译生成逻辑执行计划。

（3）优化器（Query Optimizer）：对逻辑执行计划进行优化。

（4）执行器（Execution）：把逻辑执行计划转换成可以运行的物理计划。对于Hive来说，就是MR/Spark。

##### 运行机制

![](https://tva1.sinaimg.cn/large/006tNbRwly1ga7oh70xcxj30t80cyn0e.jpg)

Hive通过给用户提供的一系列交互接口，接收到用户的指令(SQL)，使用自己的Driver，结合元数据(MetaStore)，将这些指令翻译成MapReduce，提交到Hadoop中执行，最后，将执行返回的结果输出到用户交互接口。

##### Hive和数据库比较

由于 Hive 采用了类似SQL 的查询语言 HQL(Hive Query Language)，因此很容易将 Hive 理解为数据库。其实从结构上来看，Hive 和数据库除了拥有类似的查询语言，再无类似之处。本文将从多个方面来阐述 Hive 和数据库的差异。数据库可以用在 Online 的应用中，但是Hive 是为数据仓库而设计的，清楚这一点，有助于从应用角度理解 Hive 的特性。

- 查询语言

由于SQL被广泛的应用在数据仓库中，因此，专门针对Hive的特性设计了类SQL的查询语言HQL。熟悉SQL开发的开发者可以很方便的使用Hive进行开发。

- 数据存储位置

Hive 是建立在 Hadoop 之上的，所有 Hive 的数据都是存储在 HDFS 中的。而数据库则可以将数据保存在块设备或者本地文件系统中。

- 数据更新

由于Hive是针对数据仓库应用设计的，而数据仓库的内容是读多写少的。因此，Hive中不建议对数据的改写，所有的数据都是在加载的时候确定好的。而数据库中的数据通常是需要经常进行修改的，因此可以使用 INSERT INTO … VALUES 添加数据，使用 UPDATE … SET修改数据。

- 执行

Hive中大多数查询的执行是通过 Hadoop 提供的 MapReduce 来实现的。而数据库通常有自己的执行引擎。

- 执行延迟

Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致 Hive 执行延迟高的因素是 MapReduce框架。由于MapReduce 本身具有较高的延迟，因此在利用MapReduce 执行Hive查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。

- 可扩展性

由于Hive是建立在Hadoop之上的，因此Hive的可扩展性是和Hadoop的可扩展性是一致的（世界上最大的Hadoop 集群在 Yahoo!，2009年的规模在4000 台节点左右）。而数据库由于 ACID 语义的严格限制，扩展行非常有限。目前最先进的并行数据库 [Oracle](http://lib.csdn.net/base/oracle) 在理论上的扩展能力也只有100台左右。

- 数据规模

由于Hive建立在集群上并可以利用MapReduce进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。

# 安装

##### Hive安装及配置

（1）把apache-hive-1.2.1-bin.tar.gz上传到linux的/opt/software目录下

（2）解压apache-hive-1.2.1-bin.tar.gz到/opt/module/目录下面

```
[root@hadoop100 software]$ tar -zxvf apache-hive-1.2.1-bin.tar.gz -C /opt/module/
```

（3）修改apache-hive-1.2.1-bin.tar.gz的名称为hive

```
[root@hadoop100 module]$ mv apache-hive-1.2.1-bin/ hive
```

（4）修改/opt/module/hive/conf目录下的hive-env.sh.template名称为hive-env.sh

```
[root@hadoop100 conf]$ mv hive-env.sh.template hive-env.sh
```

​    （5）配置hive-env.sh文件

​    （a）配置HADOOP_HOME路径

```
export HADOOP_HOME=/opt/module/hadoop-2.7.2
```

​    （b）配置HIVE_CONF_DIR路径

```
export HIVE_CONF_DIR=/opt/module/hive/conf
```

2．Hadoop集群配置

（1）必须启动hdfs和yarn

```
[root@hadoop100 hadoop-2.7.2]$ sbin/start-dfs.sh

[root@hadoop103 hadoop-2.7.2]$ sbin/start-yarn.sh
```

（2）在HDFS上创建/tmp和/user/hive/warehouse两个目录并修改他们的同组权限可写

```
[root@hadoop100 hadoop-2.7.2]$ bin/hadoop fs -mkdir /tmp

[root@hadoop100 hadoop-2.7.2]$ bin/hadoop fs -mkdir -p /user/hive/warehouse
```

```
[root@hadoop100 hadoop-2.7.2]$ bin/hadoop fs -chmod g+w /tmp

[root@hadoop100 hadoop-2.7.2]$ bin/hadoop fs -chmod g+w /user/hive/warehouse
```

3．Hive基本操作

（1）启动hive

```
[root@hadoop100 hive]$ bin/hive
```

（2）查看数据库

```
hive> show databases;
```

（3）打开默认数据库

```
hive> use default;
```

（4）显示default数据库中的表

```
hive> show tables;
```

（5）创建一张表

```
hive> create table student(id int, name string);
```

（6）显示数据库中有几张表

```
hive> show tables;
```

（7）查看表的结构

```
hive> desc student;
```

（8）向表中插入数据

```
hive> insert into student values(1000,"ss");
```

（9）查询表中数据

```
hive> select * from student;
```

（10）退出hive

```
hive> quit;
```

说明：（查看hive在hdfs中的结构）

数据库：在hdfs中表现为${hive.metastore.warehouse.dir}目录下一个文件夹

表：在hdfs中表现所属db目录下一个文件夹，文件夹中存放该表中的具体数据

##### 将本地文件导入Hive案例

需求

将本地/opt/module/datas/student.txt这个目录下的数据导入到hive的student(id int, name string)表中。

1．数据准备

在/opt/module/datas这个目录下准备数据

（1）在/opt/module/目录下创建datas

```
[root@hadoop100 module]$ mkdir datas
```

（2）在/opt/module/datas/目录下创建student.txt文件并添加数据

```
[root@hadoop100 datas]$ touch student.txt

[root@hadoop100 datas]$ vi student.txt

1001 zhangshan

1002 lishi

1003 zhaoliu
```

注意以tab键间隔。

2．Hive实际操作

（1）启动hive

```
[root@hadoop100 hive]$ bin/hive
```

（2）显示数据库

```
hive> show databases;
```

（3）使用default数据库

```
hive> use default;
```

（4）显示default数据库中的表

```
hive> show tables;
```

（5）删除已创建的student表

```
hive> drop table student;
```

（6）创建student表, 并声明文件分隔符’\t’

```
hive> create table student(id int, name string) ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t';
```

（7）加载/opt/module/datas/student.txt 文件到student数据库表中。

```
hive> load data local inpath '/opt/module/datas/student.txt' into table student;
```

（8）Hive查询结果

```
hive> select * from student;

OK

1001 zhangshan

1002 lishi

1003 zhaoliu

Time taken: 0.266 seconds, Fetched: 3 row(s)
```

3．遇到的问题

再打开一个客户端窗口启动hive，会产生java.sql.SQLException异常。

原因是，Metastore默认存储在自带的derby数据库中，推荐使用MySQL存储Metastore;

##### MySql中user表中主机配置

配置只要是root用户+密码，在任何主机上都能登录MySQL数据库。

1．进入mysql

```
[root@hadoop100 mysql-libs]# mysql -uroot -p000000
```

2．显示数据库

```
mysql>show databases;
```

3．使用mysql数据库

```
mysql>use mysql;
```

4．展示mysql数据库中的所有表

```
mysql>show tables;
```

5．展示user表的结构

```
mysql>desc user;
```

6．查询user表

```
mysql>select User, Host, Password from user;
```

7．修改user表，把Host表内容修改为%

```
mysql>update user set host='%' where host='localhost';
```

8．删除root用户的其他host

```
mysql>delete from user where Host='hadoop100';

mysql>delete from user where Host='127.0.0.1';

mysql>delete from user where Host='::1';
```

9．刷新

```
mysql>flush privileges;
```

10．退出

```
mysql>quit;
```

##### Hive元数据配置到MySql

- 驱动拷贝

1．在/opt/software/mysql-libs目录下解压mysql-connector-java-5.1.27.tar.gz驱动包

```
[root@hadoop100 mysql-libs]# tar -zxvf mysql-connector-java-5.1.27.tar.gz
```

2．拷贝/opt/software/mysql-libs/mysql-connector-java-5.1.27目录下的mysql-connector-java-5.1.27-bin.jar到/opt/module/hive/lib/

```
[root@hadoop100 mysql-connector-java-5.1.27]# cp mysql-connector-java-5.1.27-bin.jar /opt/module/hive/lib/
```

- 配置Metastore到MySql

1．在/opt/module/hive/conf目录下创建一个hive-site.xml

```
[root@hadoop100 conf]$ touch hive-site.xml
[root@hadoop100 conf]$ vi hive-site.xml
```

2．根据官方文档配置参数，拷贝数据到hive-site.xml文件中

```xml
<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="configuration.xsl"?>
<configuration>
  <property>
   <name>javax.jdo.option.ConnectionURL</name>
   <value>jdbc:mysql://hadoop100:3306/metastore?createDatabaseIfNotExist=true</value>
   <description>JDBC connect string for a JDBC metastore</description>
  </property>
  <property>
   <name>javax.jdo.option.ConnectionDriverName</name>
   <value>com.mysql.jdbc.Driver</value>
   <description>Driver class name for a JDBC metastore</description>
  </property>
  <property>
   <name>javax.jdo.option.ConnectionUserName</name>
   <value>root</value>
   <description>username to use against metastore database</description>
  </property>
  <property>
   <name>javax.jdo.option.ConnectionPassword</name>
   <value>000000</value>
   <description>password to use against metastore database</description>
  </property>
</configuration>
```

3．配置完毕后，如果启动hive异常，可以重新启动虚拟机。（重启后，别忘了启动hadoop集群）

##### Hive常用交互命令

1．“-e”不进入hive的交互窗口执行sql语句

```
[root@hadoop100 hive]$ bin/hive -e "select id from student;"
```

2．“-f”执行脚本中sql语句

​    （1）在/opt/module/datas目录下创建hivef.sql文件

```
[root@hadoop100 datas]$ touch hivef.sql
```

​       文件中写入正确的sql语句 select *from student;

​    （2）执行文件中的sql语句

```
[root@hadoop100 hive]$ bin/hive -f /opt/module/datas/hivef.sql
```

（3）执行文件中的sql语句并将结果写入文件中

```
[root@hadoop100 hive]$ bin/hive -f /opt/module/datas/hivef.sql > /opt/module/datas/hive_result.txt
```

##### Hive常见属性配置

- Hive数据仓库位置配置

​    1）Default数据仓库的最原始位置是在hdfs上的：/user/hive/warehouse路径下。

​    2）在仓库目录下，没有对默认的数据库default创建文件夹。如果某张表属于default数据库，直接在数据仓库目录下创建一个文件夹。

​    3）修改default数据仓库原始位置（将hive-default.xml.template如下配置信息拷贝到hive-site.xml文件中）。

```xml
<property>
<name>hive.metastore.warehouse.dir</name>                <value>/user/hive/warehouse</value>  
<description>location of default database for  the warehouse
  </description>  
</property>  
```

配置同组用户有执行权限

```
bin/hdfs dfs -chmod g+w /user/hive/warehouse
```

- Hive运行日志信息配置

1．Hive的log默认存放在/tmp/root/hive.log目录下（当前用户名下）

2．修改hive的log存放日志到/opt/module/hive/logs

 （1）修改/opt/module/hive/conf/hive-log4j.properties.template文件名称为

hive-log4j.properties

```
[root@hadoop100 conf]$ pwd

/opt/module/hive/conf

[root@hadoop100 conf]$ mv hive-log4j.properties.template hive-log4j.properties
```

 （2）在hive-log4j.properties文件中修改log存放位置

```
hive.log.dir=/opt/module/hive/logs
```

- 参数配置方式

1．查看当前所有的配置信息

```
hive>set;
```

2．参数的配置三种方式

​    （1）配置文件方式

默认配置文件：hive-default.xml 

用户自定义配置文件：hive-site.xml

​    注意：用户自定义配置会覆盖默认配置。另外，Hive也会读入Hadoop的配置，因为Hive是作为Hadoop的客户端启动的，Hive的配置会覆盖Hadoop的配置。配置文件的设定对本机启动的所有Hive进程都有效。

（2）命令行参数方式

启动Hive时，可以在命令行添加-hiveconf param=value来设定参数。

例如：

```
[root@hadoop103 hive]$ bin/hive -hiveconf mapred.reduce.tasks=10;
```

注意：仅对本次hive启动有效

查看参数设置：

```
hive (default)> set mapred.reduce.tasks;
```

（3）参数声明方式

可以在HQL中使用SET关键字设定参数

例如：

```
hive (default)> set mapred.reduce.tasks=100;
```

注意：仅对本次hive启动有效。

查看参数设置

```
hive (default)> set mapred.reduce.tasks;
```

# 数据类型

##### 基本数据类型

| Hive数据类型 | Java数据类型 | 长度                                                 |                 例子                 |
| ------------ | ------------ | ---------------------------------------------------- | :----------------------------------: |
| TINYINT      | byte         | 1byte有符号整数                                      |                  20                  |
| SMALINT      | short        | 2byte有符号整数                                      |                  20                  |
| INT          | int          | 4byte有符号整数                                      |                  20                  |
| BIGINT       | long         | 8byte有符号整数                                      |                  20                  |
| BOOLEAN      | boolean      | 布尔类型，true或者false                              |              TRUE FALSE              |
| FLOAT        | float        | 单精度浮点数                                         |               3.14159                |
| DOUBLE       | double       | 双精度浮点数                                         |               3.14159                |
| STRING       | string       | 字符系列。可以指定字符集。可以使用单引号或者双引号。 | ‘now is the time’ “for all good men” |
| TIMESTAMP    |              | 时间类型                                             |                                      |
| BINARY       |              | 字节数组                                             |                                      |

##### 集合数据类型

| 数据类型 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| STRUCT   | 和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last STRING},那么第1个元素可以通过字段.first来引用。 |
| MAP      | MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键->值对是’first’->’John’和’last’->’Doe’，那么可以通过字段名[‘last’]获取最后一个元素 |
| ARRAY    | 数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’,  ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。 |

1） 假设某表有如下一行，我们用JSON格式来表示其数据结构。在Hive下访问的格式为



2）基于上述数据结构，我们在Hive里创建对应的表，并导入数据。 

创建本地测试文件test.txt



注意：MAP，STRUCT和ARRAY里的元素间关系都可以用同一个字符表示，这里用“_”。

3）Hive上创建测试表test

```sql
create table test(  name string,  friends array<string>,  children  map<string, int>,  address  struct<street:string, city:string>  )  row format delimited  fields terminated by ','  collection items  terminated by '_'  map keys terminated  by ':'  lines terminated by  '\n';  
```

字段解释：

```
row format delimited fields terminated by ',' -- 列分隔符

collection items terminated by '_'    --MAP STRUCT 和 ARRAY 的分隔符(数据分割符号)

map keys terminated by ':'             -- MAP中的key与value的分隔符

lines terminated by '\n';               -- 行分隔符
```

4）导入文本数据到测试表

```
hive (default)> load data local inpath ‘/opt/module/datas/test.txt’into table test
```

5）访问三种集合列里的数据，以下分别是ARRAY，MAP，STRUCT的访问方式

```
 hive (default)>  select friends[1],children['xiao song'],address.city from test  where  name="songsong";  
```

##### 类型转化

Hive的原子数据类型是可以进行隐式转换的，类似于Java的类型转换，例如某表达式使用INT类型，TINYINT会自动转换为INT类型，但是Hive不会进行反向转化，例如，某表达式使用TINYINT类型，INT不会自动转换为TINYINT类型，它会返回错误，除非使用CAST操作。

1．隐式类型转换规则如下

（1）任何整数类型都可以隐式地转换为一个范围更广的类型，如TINYINT可以转换成INT，INT可以转换成BIGINT。

（2）所有整数类型、FLOAT和STRING类型都可以隐式地转换成DOUBLE。

（3）TINYINT、SMALLINT、INT都可以转换为FLOAT。

（4）BOOLEAN类型不可以转换为任何其它的类型。

2．可以使用CAST操作显示进行数据类型转换

例如CAST('1' AS INT)将把字符串'1' 转换成整数1；如果强制类型转换失败，如执行CAST('X' AS INT)，表达式返回空值 NULL。

# DDL数据定义

##### 创建数据库

```sql
CREATE DATABASE [IF NOT EXISTS] database_name

[COMMENT database_comment]

[LOCATION hdfs_path]

[WITH DBPROPERTIES (property_name=property_value, ...)];
```

1）创建一个数据库，数据库在HDFS上的默认存储路径是/user/hive/warehouse/*.db。

```
hive (default)> create database db_hive;
```

2）避免要创建的数据库已经存在错误，增加if not exists判断。（标准写法）

```
hive (default)> create database if not exists db_hive;   
```

3）创建一个数据库，指定数据库在HDFS上存放的位置

```
hive (default)> create database db_hive2 location '/db_hive2.db';
```

##### 查询数据库

- 显示数据库

1．显示数据库

```
hive> show databases;
```

2．过滤显示查询的数据库

```
hive> show databases like 'db_hive*';
```

- 查看数据库详情

1．显示数据库信息

```
hive> desc database db_hive;
```

2．显示数据库详细信息，extended

```
hive> desc database extended db_hive;
```

- 切换当前数据库

```
hive (default)> use db_hive;
```

##### 修改数据库

用户可以使用ALTER DATABASE命令为某个数据库的DBPROPERTIES设置键-值对属性值，来描述这个数据库的属性信息。数据库的其他元数据信息都是不可更改的，包括数据库名和数据库所在的目录位置。

```
hive (default)> alter database db_hive set dbproperties('createtime'='20170830');
```

##### 删除数据库

1．删除空数据库

```
hive>drop database db_hive2;
```

2．如果删除的数据库不存在，最好采用 if exists判断数据库是否存在

```
hive> drop database if exists db_hive2;
```

3．如果数据库不为空，可以采用cascade命令，强制删除

```
hive> drop database db_hive cascade;
```

##### 创建表

1．建表语法

```sql
CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name 

[(col_name data_type [COMMENT col_comment], ...)] 

[COMMENT table_comment] 

[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] 

[CLUSTERED BY (col_name, col_name, ...) 

[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] 

[ROW FORMAT row_format] 

[STORED AS file_format] 

[LOCATION hdfs_path]

[TBLPROPERTIES (property_name=property_value, ...)]

[AS select_statement]
```

2．字段解释说明 

（1）CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXISTS 选项来忽略这个异常。

（2）EXTERNAL关键字可以让用户创建一个外部表，在建表的同时可以指定一个指向实际数据的路径（LOCATION），在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。

（3）COMMENT：为表和列添加注释。

（4）PARTITIONED BY创建分区表

（5）CLUSTERED BY创建分桶表

（6）SORTED BY不常用，对桶中的一个或多个列另外排序

（7）ROW FORMAT 

DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char]

​    [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] 

  | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, ...)]

用户在建表的时候可以自定义SerDe或者使用自带的SerDe。如果没有指定ROW FORMAT 或者ROW FORMAT DELIMITED，将会使用自带的SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的SerDe，Hive通过SerDe确定表的具体的列的数据。

SerDe是Serialize/Deserilize的简称， hive使用Serde进行行对象的序列与反序列化。

（8）STORED AS指定存储文件类型

常用的存储文件类型：SEQUENCEFILE（二进制序列文件）、TEXTFILE（文本）、RCFILE（列式存储格式文件）

如果文件数据是纯文本，可以使用STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。

（9）LOCATION ：指定表在HDFS上的存储位置。

（10）AS：后跟查询语句，根据查询结果创建表。

（11）LIKE允许用户复制现有的表结构，但是不复制数据。

##### 管理表

1．理论

默认创建的表都是所谓的管理表，有时也被称为内部表。因为这种表，Hive会（或多或少地）控制着数据的生命周期。Hive默认情况下会将这些表的数据存储在由配置项hive.metastore.warehouse.dir(例如，/user/hive/warehouse)所定义的目录的子目录下。  当我们删除一个管理表时，Hive也会删除这个表中数据。管理表不适合和其他工具共享数据。

2．案例实操

（1）普通创建表

```sql
create table if not exists student2(  id int, name string  )  row format delimited fields terminated by '\t'  stored as textfile  location '/user/hive/warehouse/student2';   
```

（2）根据查询结果创建表（查询的结果会添加到新创建的表中）

```sql
create  table if not exists student3 as select id, name from student;  
```





##### 外部表

1．理论

因为表是外部表，所以Hive并非认为其完全拥有这份数据。删除该表并不会删除掉这份数据，不过描述表的元数据信息会被删除掉。

2．管理表和外部表的使用场景

每天将收集到的网站日志定期流入HDFS文本文件。在外部表（原始日志表）的基础上做大量的统计分析，用到的中间表、结果表使用内部表存储，数据通过SELECT+INSERT进入内部表。

3．案例实操

分别创建部门和员工外部表，并向表中导入数据。

（1）   上传数据到HDFS

```
hive (default)> dfs -mkdir /student;  
hive (default)> dfs -put /opt/module/datas/student.txt /student;
```

（2）建表语句

  创建外部表

```
hive  (default)> create external table stu_external(  id  int,   name  string)   row format  delimited fields terminated by '\t'   location '/student';  
```

（3）查看创建的表

```
hive (default)> select * from stu_external;
```

（4）查看表格式化数据

```
hive (default)> desc formatted dept;
```

（5）删除外部表

```
hive (default)> drop table stu_external;
```

外部表删除后，hdfs中的数据还在，但是metadata中stu_external的元数据已被删除

##### 管理表与外部表的互相转换

（1）查询表的类型

```
hive (default)> desc formatted student2;

Table Type:       MANAGED_TABLE
```

（2）修改内部表student2为外部表

```
alter table student2 set tblproperties('EXTERNAL'='TRUE');
```

（3）查询表的类型

```
hive (default)> desc formatted student2;

Table Type:       EXTERNAL_TABLE
```

（4）修改外部表student2为内部表

```
alter table student2 set tblproperties('EXTERNAL'='FALSE');
```

（5）查询表的类型

```
hive (default)> desc formatted student2;

Table Type:       MANAGED_TABLE
```

注意：('EXTERNAL'='TRUE')和('EXTERNAL'='FALSE')为固定写法，区分大小写！

##### 分区表

分区表实际上就是对应一个HDFS文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。Hive中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过WHERE子句中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。

- 分区表基本操作

1．引入分区表（需要根据日期对日志进行管理）

/user/hive/warehouse/log_partition/20170702/20170702.log

/user/hive/warehouse/log_partition/20170703/20170703.log

/user/hive/warehouse/log_partition/20170704/20170704.log

2．创建分区表语法

```sql
hive (default)> create table dept_partition(  deptno int, dname string, loc string  )  partitioned by (month string)  row format delimited fields terminated by '\t';  
```



3．加载数据到分区表中

```sql
hive (default)> load data local inpath '/opt/module/datas/dept.txt' into table default.dept_partition partition(month='201709');

hive (default)> load data local inpath '/opt/module/datas/dept.txt' into table default.dept_partition partition(month='201708');

hive (default)> load data local inpath '/opt/module/datas/dept.txt' into table default.dept_partition partition(month='201707’);
```

注意：分区表加载数据时，必须指定分区

4．查询分区表中数据

 单分区查询

```
hive (default)> select * from dept_partition where month='201709';
```

多分区联合查询

```
hive (default)> select * from dept_partition where month='201709'
union
select * from dept_partition where month='201708'
union
select * from dept_partition where month='201707';
```

5．增加分区

​    创建单个分区

```
hive (default)> alter table dept_partition add partition(month='201706') ;
```

   同时创建多个分区

```
hive (default)> alter table dept_partition add partition(month='201705') partition(month='201704');
```

6．删除分区

​    删除单个分区

```
hive (default)> alter table dept_partition drop partition (month='201704');
```

同时删除多个分区

```
hive (default)> alter table dept_partition drop partition (month='201705'), partition (month='201706');
```

7．查看分区表有多少分区

```
hive> show partitions dept_partition;
```

8．查看分区表结构

```
hive> desc formatted dept_partition;
```

- 分区表注意事项

1．创建二级分区表

```sql
hive (default)> create table dept_partition2(           deptno int, dname string, loc string           )          partitioned by (month string, day string)           row format delimited fields terminated by '\t';  
```

2．正常的加载数据

（1）加载数据到二级分区表中

```
hive (default)> load data local inpath '/opt/module/datas/dept.txt' into table
 default.dept_partition2 partition(month='201709', day='13');
```

（2）查询分区数据

```
hive (default)> select * from dept_partition2 where month='201709' and day='13';
```

3．把数据直接上传到分区目录上，让分区表和数据产生关联的三种方式

（1）方式一：上传数据后修复

​    上传数据

```
hive (default)> dfs -mkdir -p
 /user/hive/warehouse/dept_partition2/month=201709/day=12;
hive (default)> dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=12;
```

​    查询数据（查询不到刚上传的数据）

```
hive (default)> select * from dept_partition2 where month='201709' and day='12';
```

执行修复命令

```
hive> msck repair table dept_partition2;
```

再次查询数据

```
hive (default)> select * from dept_partition2 where month='201709' and day='12';
```

（2）方式二：上传数据后添加分区

​    上传数据

```
hive (default)> dfs -mkdir -p
 /user/hive/warehouse/dept_partition2/month=201709/day=11;
hive (default)> dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=11;
```

​    执行添加分区

```
hive (default)> alter table dept_partition2 add partition(month='201709',day='11');
```

​    查询数据

```
hive (default)> select * from dept_partition2 where month='201709' and day='11';
```

（3）方式三：创建文件夹后load数据到分区

 创建目录

```
hive (default)> dfs -mkdir -p
 /user/hive/warehouse/dept_partition2/month=201709/day=10;
```

上传数据

```
hive (default)> load data local inpath '/opt/module/datas/dept.txt' into table
 dept_partition2 partition(month='201709',day='10');
```

查询数据

```
hive (default)> select * from dept_partition2 where month='201709' and day='10';
```

##### 修改表

- 重命名表

1．语法

```
ALTER TABLE table_name RENAME TO new_table_name
```

2．实操案例

```
hive (default)> alter table dept_partition2 rename to dept_partition3;
```

- 增加/修改/替换列信息

1．语法

  更新列

```sql
ALTER TABLE table_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name]
```

增加和替换列

```sql
ALTER TABLE table_name ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...) 
```

注：ADD是代表新增一字段，字段位置在所有列后面(partition列前)，REPLACE则是表示替换表中所有字段。

2．实操案例

（1）查询表结构

```
hive> desc dept_partition;
```

（2）添加列

```
hive (default)> alter table dept_partition add columns(deptdesc string);
```

（3）查询表结构

```
hive> desc dept_partition;
```

（4）更新列

```
hive (default)> alter table dept_partition change column deptdesc desc int;
```

（5）查询表结构

```
hive> desc dept_partition;
```

（6）替换列

```
hive (default)> alter table dept_partition replace columns(deptno string, dname string, loc string);
```

- 删除表

```
hive (default)> drop table dept_partition;
```

# DML数据操作

##### 数据导入

- 向表中装载数据（Load）

1．语法

```
hive> load data [local] inpath '/opt/module/datas/student.txt' [overwrite] into table student [partition (partcol1=val1,…)];
```

（1）load data:表示加载数据

（2）local:表示从本地加载数据到hive表；否则从HDFS加载数据到hive表

（3）inpath:表示加载数据的路径

（4）overwrite:表示覆盖表中已有数据，否则表示追加

（5）into table:表示加载到哪张表

（6）student:表示具体的表

（7）partition:表示上传到指定分区

2．实操案例

（0）创建一张表

```sql
hive (default)> create table student(id string, name string) row format delimited fields terminated by '\t';
```

（1）加载本地文件到hive

```sql
hive (default)> load data local inpath '/opt/module/datas/student.txt' into table default.student;
```

（2）加载HDFS文件到hive中

  上传文件到HDFS

```sql
hive (default)> dfs -put /opt/module/datas/student.txt /user/root/hive;
```

加载HDFS上数据

```
hive (default)> load data inpath '/user/root/hive/student.txt' into table default.student;
```

（3）加载数据覆盖表中已有的数据

上传文件到HDFS

```
hive (default)> dfs -put /opt/module/datas/student.txt /user/root/hive;
```

加载数据覆盖表中已有的数据

```
hive (default)> load data inpath '/user/root/hive/student.txt' overwrite into table default.student;
```

- 通过查询语句向表中插入数据（Insert）

1．创建一张分区表

```
hive (default)> create table student(id int, name string) partitioned by (month string) row format delimited fields terminated by '\t';
```

2．基本插入数据

```
hive (default)> insert into table student partition(month='201709') values(1,'wangwu'),(2,’zhaoliu’);
```

3．基本模式插入（根据单张表查询结果）

```
hive (default)> insert overwrite table student partition(month='201708') select id, name from student where month='201709';
```

insert into：以追加数据的方式插入到表或分区，原有数据不会删除

insert overwrite：会覆盖表或分区中已存在的数据

注意：insert不支持插入部分字段

4．多表（多分区）插入模式（根据多张表查询结果）

```
hive (default)> from student
insert overwrite table student partition(month='201707')
select id, name where month='201709'
insert overwrite table student partition(month='201706')
select id, name where month='201709';
```

- 查询语句中创建表并加载数据（As Select）

```sql
create table if not exists student3
as select id, name from student;
```

- 创建表时通过Location指定加载数据路径

1．上传数据到hdfs上

```
hive (default)> dfs -mkdir /student;  
hive (default)> dfs -put /opt/module/datas/student.txt /student;
```

2. 创建表，并指定在hdfs上的位置

```sql
hive (default)> create external table if not exists student5(
id int, name string) row format delimited fields terminated by '\t' location '/student;
```

3．查询数据

```
hive (default)> select * from student5;
```

- import数据到指定Hive表中

注意：先用export导出后，再将数据导入。

```
hive (default)> import table student2 partition(month='201709') from '/user/hive/warehouse/export/student';
```

##### 数据导出

- Insert导出

1．将查询的结果导出到本地

```sql
hive (default)> insert overwrite local directory '/opt/module/datas/export/student' select * from student;
```

2．将查询的结果格式化导出到本地

```sql
hive(default)>insert overwrite local directory '/opt/module/datas/export/student1' ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' select * from student;
```

3．将查询的结果导出到HDFS上(没有local)

```sql
hive (default)> insert overwrite directory '/user/root/student2'
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' 
select * from student;
```

-  Hadoop命令导出到本地

```
hive (default)> dfs -get /user/hive/warehouse/student/month=201709/000000_0
/opt/module/datas/export/student3.txt;
```

- Hive Shell 命令导出

基本语法：（hive -f/-e 执行语句或者脚本 > file）

```
[root@hadoop100 hive]$ bin/hive -e 'select * from default.student;' >/opt/module/datas/export/student4.txt;
```

##### 清除表中数据（Truncate）

注意：Truncate只能删除管理表，不能删除外部表中数据

```
hive (default)> truncate table student;
```

# 查询

基本语法同普通的sql,这里挑一些重点来讲。

- 比较运算符（Between/In/ Is Null）

下面表中描述了谓词操作符，这些操作符同样可以用于JOIN…ON和HAVING语句中。这里主要是看下对NULL值的处理。

| 操作符                  | 支持的数据类型 | 描述                                                         |
| ----------------------- | -------------- | ------------------------------------------------------------ |
| A=B                     | 基本数据类型   | 如果A等于B则返回TRUE，反之返回FALSE                          |
| A<=>B                   | 基本数据类型   | 如果A和B都为NULL，则返回TRUE，其他的和等号（=）操作符的结果一致，如果任一为NULL则结果为NULL |
| A<>B, A!=B              | 基本数据类型   | A或者B为NULL则返回NULL；如果A不等于B，则返回TRUE，反之返回FALSE |
| A<B                     | 基本数据类型   | A或者B为NULL，则返回NULL；如果A小于B，则返回TRUE，反之返回FALSE |
| A<=B                    | 基本数据类型   | A或者B为NULL，则返回NULL；如果A小于等于B，则返回TRUE，反之返回FALSE |
| A>B                     | 基本数据类型   | A或者B为NULL，则返回NULL；如果A大于B，则返回TRUE，反之返回FALSE |
| A>=B                    | 基本数据类型   | A或者B为NULL，则返回NULL；如果A大于等于B，则返回TRUE，反之返回FALSE |
| A [NOT] BETWEEN B AND C | 基本数据类型   | 如果A，B或者C任一为NULL，则结果为NULL。如果A的值大于等于B而且小于或等于C，则结果为TRUE，反之为FALSE。如果使用NOT关键字则可达到相反的效果。 |
| A IS NULL               | 所有数据类型   | 如果A等于NULL，则返回TRUE，反之返回FALSE                     |
| A IS NOT NULL           | 所有数据类型   | 如果A不等于NULL，则返回TRUE，反之返回FALSE                   |
| IN(数值1, 数值2)        | 所有数据类型   | 使用 IN运算显示列表中的值                                    |
| A [NOT] LIKE B          | STRING 类型    | B是一个SQL下的简单正则表达式，也叫通配符模式，如果A与其匹配的话，则返回TRUE；反之返回FALSE。B的表达式说明如下：‘x%’表示A必须以字母‘x’开头，‘%x’表示A必须以字母’x’结尾，而‘%x%’表示A包含有字母’x’,可以位于开头，结尾或者字符串中间。如果使用NOT关键字则可达到相反的效果。 |
| A RLIKE B, A REGEXP B   | STRING 类型    | B是基于java的正则表达式，如果A与其匹配，则返回TRUE；反之返回FALSE。匹配使用的是JDK中的正则表达式接口实现的，因为正则也依据其中的规则。例如，正则表达式必须和整个字符串A相匹配，而不是只需与其字符串匹配。 |

1）使用LIKE运算选择类似的值

2）选择条件可以包含字符或数字:

% 代表零个或多个字符(任意个字符)。

_ 代表一个字符。

3）RLIKE子句是Hive中这个功能的一个扩展，其可以通过Java的正则表达式这个更强大的语言来指定匹配条件。

4）案例实操

​    （1）查找以2开头薪水的员工信息

hive (default)> select * from emp where sal LIKE '2%';

​    （2）查找第二个数值为2的薪水的员工信息

hive (default)> select * from emp where sal LIKE '_2%';

​    （3）查找薪水中含有2的员工信息

hive (default)> select * from emp where sal RLIKE '[2]';

- 连接谓词中不支持or

hive join目前不支持在on子句中使用谓词or

- 空字段赋值

1. 函数说明

NVL：给值为NULL的数据赋值，它的格式是NVL( value，default_value)。它的功能是如果value为NULL，则NVL函数返回default_value的值，否则返回value的值，如果两个参数都为NULL ，则返回NULL。

2. 数据准备：采用员工表

3. 查询：如果员工的comm为NULL，则用-1代替

```
hive (default)> select comm,nvl(comm, -1) from emp;
```

4. 查询：如果员工的comm为NULL，则用领导id代替

```
hive (default)> select comm, nvl(comm,mgr) from emp;
```

- CASE WHEN

1. 数据准备

| name | dept_id | sex  |
| ---- | ------- | ---- |
| 悟空 | A       | 男   |
| 大海 | A       | 男   |
| 宋宋 | B       | 男   |
| 凤姐 | A       | 女   |
| 婷姐 | B       | 女   |
| 婷婷 | B       | 女   |

2．需求

求出不同部门男女各多少人。

3．创建本地emp_sex.txt，导入数据

[root@hadoop100 datas]$ vi emp_sex.txt

4．创建hive表并导入数据

```sql
CREATE TABLE emp_sex(name string,
                     dept_id string,
                     sex string) ROW format delimited fields terminated BY "\t";

LOAD DATA LOCAL inpath '/opt/module/datas/emp_sex.txt' INTO TABLE emp_sex;
```

5．按需求查询数据

```sql
SELECT dept_id,
       sum(CASE sex
               WHEN '男' THEN 1
               ELSE 0
           END) male_count,
       sum(CASE sex
               WHEN '女' THEN 1
               ELSE 0
           END) female_count
FROM emp_sex
GROUP BY dept_id;
```

- 行转列

1．相关函数说明

CONCAT(string A/col, string B/col…)：返回输入字符串连接后的结果，支持任意个输入字符串;

CONCAT_WS(separator, str1, str2,...)：它是一个特殊形式的 CONCAT()。第一个参数是剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;

COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。

2．数据准备

| name   | constellation | blood_type |
| ------ | ------------- | ---------- |
| 孙悟空 | 白羊座        | A          |
| 大海   | 射手座        | A          |
| 宋宋   | 白羊座        | B          |
| 猪八戒 | 白羊座        | A          |
| 凤姐   | 射手座        | A          |

3．需求

把星座和血型一样的人归类到一起。结果如下：

射手座,A      大海|凤姐

白羊座,A      孙悟空|猪八戒

白羊座,B       宋宋

4．创建本地constellation.txt，导入数据

[root@hadoop100 datas]$ vi constellation.txt

5．创建hive表并导入数据

```sql
CREATE TABLE person_info(name string,
                         constellation string,
                         blood_type string) ROW format delimited fields terminated BY "\t";
LOAD DATA LOCAL inpath "/opt/module/datas/constellation.txt" INTO TABLE person_info;
```

6．按需求查询数据

```sql
SELECT t1.base,
       concat_ws('|', collect_set(t1.name)) name
FROM
  (SELECT name,
          concat(constellation, ",", blood_type) base
   FROM person_info) t1
GROUP BY t1.base;
```

- 列转行

1．函数说明

EXPLODE(col)：将hive一列中复杂的array或者map结构拆分成多行。

LATERAL VIEW

用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias

解释：用于和split, explode等UDTF一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。

2．数据准备

| movie          | category                 |
| -------------- | ------------------------ |
| 《疑犯追踪》   | 悬疑,动作,科幻,剧情      |
| 《Lie  to me》 | 悬疑,警匪,动作,心理,剧情 |
| 《战狼2》      | 战争,动作,灾难           |

3．需求

将电影分类中的数组数据展开。结果如下：

《疑犯追踪》   悬疑

《疑犯追踪》   动作

《疑犯追踪》   科幻

《疑犯追踪》   剧情

《Lie to me》  悬疑

《Lie to me》  警匪

《Lie to me》  动作

《Lie to me》  心理

《Lie to me》  剧情

《战狼2》     战争

《战狼2》     动作

《战狼2》     灾难

4．创建本地movie.txt，导入数据

[root@hadoop100 datas]$ vi movie.txt

5．创建hive表并导入数据

```sql
CREATE TABLE movie_info(movie string,
                        category array<string>) ROW format delimited fields terminated BY "\t" collection items terminated BY ",";

LOAD DATA LOCAL inpath "/opt/module/datas/movie.txt" INTO TABLE movie_info;

```

6．按需求查询数据

```sql
SELECT movie,
       category_name
FROM movie_info LATERAL VIEW explode(category) table_tmp AS category_name;
```

- 窗口函数（开窗函数）

1．相关函数说明

OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化。

CURRENT ROW：当前行

n PRECEDING：往前n行数据

n FOLLOWING：往后n行数据

UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING表示到后面的终点

LAG(col,n,default_val)：往前第n行数据

LEAD(col,n, default_val)：往后第n行数据

2．数据准备：

```
name，orderdate，cost
jack,2017-01-01,10  
tony,2017-01-02,15  
jack,2017-02-03,23  
tony,2017-01-04,29  
jack,2017-01-05,46  
jack,2017-04-06,42  
tony,2017-01-07,50  
jack,2017-01-08,55  
mart,2017-04-08,62  
mart,2017-04-09,68  
neil,2017-05-10,12  
mart,2017-04-11,75  
neil,2017-06-12,80  
mart,2017-04-13,94
```

3．需求

（1）查询在2017年4月份购买过的顾客及总人数

（2）查询顾客的购买明细及月购买总额

（3）上述的场景, 将每个顾客的cost按照日期进行累加

（4）查询每个顾客上次的购买时间

（5）查询前20%时间的订单信息

4．创建本地business.txt，导入数据

[root@hadoop100 datas]$ vi business.txt

5．创建hive表并导入数据

```sql
CREATE TABLE business(name string,
                      orderdate string,
                      cost int) ROW FORMAT DELIMITED FIELDS TERMINATED BY ',';

LOAD DATA LOCAL inpath "/opt/module/datas/business.txt" INTO TABLE business;
```

6．按需求查询数据

（1）查询在2017年4月份购买过的顾客及总人数

```sql
--不加over求的是每个人的购买次数，加了是求4月份一共有多少个人买
SELECT name,
       count(*) over ()
FROM business
WHERE substring(orderdate,1,7) = '2017-04'
GROUP BY name;
```

（2）查询顾客的购买明细及月购买总额

```sql
# 既要看细粒度数据又要看聚合数据
SELECT name,
       orderdate,
       cost,
       sum(cost) over(partition BY month(orderdate))
FROM business
```

（3）上述的场景, 将每个顾客的cost按照日期进行累加

```sql
SELECT name,
       orderdate,
       cost,
       --所有行相加 
       sum(cost) over() AS sample1,
       --按name分组，组内数据相加
       sum(cost) over(partition BY name) AS sample2,
       --按name分组，组内数据累加
       sum(cost) over(partition BY name
                      ORDER BY orderdate) AS sample3,
        --按name分组，组内数据累加
       sum(cost) over(partition BY name
                      ORDER BY orderdate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS sample4,
        --当前行和前面一行做聚合
       sum(cost) over(partition BY name
                      ORDER BY orderdate ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS sample5,
        --当前行和前边一行及后面一行  
       sum(cost) over(partition BY name
                      ORDER BY orderdate ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS sample6,
        --当前行及后面所有行
       sum(cost) over(partition BY name
                      ORDER BY orderdate ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS sample7
FROM business;
```



（4）查看顾客上次的购买时间

```sql
SELECT name,
       orderdate,
       cost,
       lag(orderdate,1,'1900-01-01') over(partition BY name
                                          ORDER BY orderdate) AS time1,
       lag(orderdate,2) over (partition BY name
                              ORDER BY orderdate) AS time2
FROM business;
```

（5）查询前20%时间的订单信息

```sql
SELECT *
FROM
  (SELECT name,
          orderdate,
          cost,
          ntile(5) over(
                        ORDER BY orderdate) sorted
   FROM business) t
WHERE sorted = 1;
```

- Rank

1．函数说明

RANK() 排序相同时会重复，总数不会变

DENSE_RANK() 排序相同时会重复，总数会减少

ROW_NUMBER() 会根据顺序计算

2．数据准备

| name   | subject | score |
| ------ | ------- | ----- |
| 孙悟空 | 语文    | 87    |
| 孙悟空 | 数学    | 95    |
| 孙悟空 | 英语    | 68    |
| 大海   | 语文    | 94    |
| 大海   | 数学    | 56    |
| 大海   | 英语    | 84    |
| 宋宋   | 语文    | 64    |
| 宋宋   | 数学    | 86    |
| 宋宋   | 英语    | 84    |
| 婷婷   | 语文    | 65    |
| 婷婷   | 数学    | 85    |
| 婷婷   | 英语    | 78    |

3．需求

计算每门学科成绩排名。

4．创建本地score.txt，导入数据

[root@hadoop100 datas]$ vi score.txt

5．创建hive表并导入数据

```sql
CREATE TABLE score(name string,
                   subject string,
                   score int) ROW format delimited fields terminated BY "\t";

LOAD DATA LOCAL inpath '/opt/module/datas/score.txt' INTO TABLE score;
```

6．按需求查询数据

```sql
SELECT name,
       subject,
       score,
       rank() over(partition BY subject
                   ORDER BY score DESC) rp,
       dense_rank() over(partition BY subject
                   ORDER BY score DESC) drp,
       row_number() over(partition BY subject
                   ORDER BY score DESC) rmp
FROM score;
```

##### 函数

- 系统内置函数

1．查看系统自带的函数

hive> show functions;

2．显示自带的函数的用法

hive> desc function upper;

3．详细显示自带的函数的用法

hive> desc function extended upper;

- 自定义函数

1）Hive 自带了一些函数，比如：max/min等，但是数量有限，自己可以通过自定义UDF来方便的扩展。

2）当Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。

3）根据用户自定义函数类别分为以下三种：

  （1）UDF（User-Defined-Function）

​     一进一出

  （2）UDAF（User-Defined Aggregation Function）

​     聚集函数，多进一出

​     类似于：count/max/min

  （3）UDTF（User-Defined Table-Generating Functions）

​     一进多出

​     如lateral view explore()

4）官方文档地址

https://cwiki.apache.org/confluence/display/Hive/HivePlugins

